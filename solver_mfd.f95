SUBROUTINE MFD_CAL(MCF,PC,X0,Y0,LINE_NUM,LINE_COR,KTH,FA_COE)
 USE POINT
 IMPLICIT NONE 
 INTEGER :: LINE_NUM
 TYPE (FACE_CAL_COR) :: LINE_COR(LINE_NUM)
 INTEGER :: IK,JK,KK
 INTEGER :: K1,K2,I,J,K
 REAL (KIND = 8) :: RH_INT,XK
 REAL (KIND = 8) :: KTH(2,2)
 REAL (KIND = 8) :: NC(LINE_NUM,2),RC(LINE_NUM,2),MCF(LINE_NUM,LINE_NUM),PC(LINE_NUM,LINE_NUM),RNC(2,2)
 REAL (KIND = 8) :: NX,NY,X0,Y0,X1,Y1,X2,Y2
 REAL (KIND = 8) :: NX0,NY0,NX1,NY1,LLX,LLY,LL,DIS
 REAL (KIND = 8) :: AL1,AL2,LAMAC
 REAL (KIND = 8) :: FA_COE(LINE_NUM)
 
 DO IK = 1,LINE_NUM
 	LINE_COR(IK)%NODE_XYZ(1,1) = LINE_COR(IK)%NODE_XYZ(1,1)-X0
 	LINE_COR(IK)%NODE_XYZ(1,2) = LINE_COR(IK)%NODE_XYZ(1,2)-Y0
 	
 	LINE_COR(IK)%NODE_XYZ(2,1) = LINE_COR(IK)%NODE_XYZ(2,1)-X0
 	LINE_COR(IK)%NODE_XYZ(2,2) = LINE_COR(IK)%NODE_XYZ(2,2)-Y0
 END DO
 
 X0 = 0.0; Y0 = 0.0
 NC = 0.0; RC = 0.0
 DO IK = 1,LINE_NUM
 	X1 = LINE_COR(IK)%NODE_XYZ(1,1); Y1 = LINE_COR(IK)%NODE_XYZ(1,2)
 	X2 = LINE_COR(IK)%NODE_XYZ(2,1); Y2 = LINE_COR(IK)%NODE_XYZ(2,2)
 	
 	NX = X2-X1; NY = Y2-Y1
 	LL = SQRT(NX*NX+NY*NY)
 	NX = NX/LL; NY = NY/LL
 	
 	NX1 = -NY; NY1 = NX
 	NX0 = -X0+0.5*(X1+X2); NY0 = -Y0+0.5*(Y1+Y2)
 	
 	LLX = NX1*NX0+NY1*NY0
 	IF (LLX.LT.0.0) THEN 
 		NX1 = -NX1; NY1 = -NY1
 	END IF
 	
 	FA_COE(IK) = ABS(LLX*LL)
 	
 	XK = KTH(1,1)*NX1+KTH(2,1)*NY1
 	RC(IK,1) = XK*LL
 	XK = KTH(2,1)*NX1+KTH(2,2)*NY1
 	RC(IK,2) = XK*LL
 	
 	K1 = 1; K2 = 0
 	CALL LINE_CAL(X1,Y1,X2,Y2,K1,K2,LLX)
 	NC(IK,1) = LLX/LL
 	K1 = 0; K2 = 1
 	CALL LINE_CAL(X1,Y1,X2,Y2,K1,K2,LLX)
 	NC(IK,2) = LLX/LL
 END DO
 
 DIS = 0.0
 DO IK = 1,LINE_NUM
 	DIS =DIS+FA_COE(IK)
 END DO
 DO IK = 1,LINE_NUM
 	FA_COE(IK) = FA_COE(IK)/DIS
 END DO
 
 RNC = 0.0
 DO IK = 1,2
 	DO KK = 1,2
 		DO JK = 1,LINE_NUM
 			RNC(IK,KK) = RNC(IK,KK)+RC(JK,IK)*NC(JK,KK)
 		END DO
 	END DO
 END DO
 
 IK = LINE_NUM; JK = 2
 CALL MFD_SOLVER_NN(IK,NC,RC,RNC,JK,MCF,PC)
 

 
END SUBROUTINE

SUBROUTINE LINE_CAL(X1,Y1,X2,Y2,K1,K2,LLX)
 IMPLICIT NONE
 REAL (KIND = 8) :: X1,Y1,X2,Y2,NX,NY,LLX,TM
 REAL (KIND = 8) :: KK,NXY,XK,YK,LOW_LINE,UP_LINE
 REAL (KIND = 8) :: KX,KY
 INTEGER :: K1,K2
 
 NX = X2-X1
 NY = Y2-Y1
 
 IF (ABS(NX).GT.1.0E-6) THEN 
 	NXY = NY/NX
 	IF (X2.LT.X1) THEN 
 		XK = X2; YK = Y2
 		X2 = X1; Y2 = Y1
 		X1 = XK; Y1 = YK
 	END IF
 	TM = 0.0
 	KX = 1.0; KY = NXY
 	CALL POLY_COE(K1,K2,X1,Y1,KX,KY,TM,LOW_LINE)
 	TM = X2-X1
 	CALL POLY_COE(K1,K2,X1,Y1,KX,KY,TM,UP_LINE)
 	LLX = (UP_LINE-LOW_LINE)*SQRT(NXY*NXY+1.0)
 ELSE 
 	NXY = NX/NY
 	IF (Y2.LT.Y1) THEN 
  		XK = X2; YK = Y2
 		X2 = X1; Y2 = Y1
 		X1 = XK; Y1 = YK
 	END IF
 	TM = 0.0
 	KX = NXY; KY = 1.0
 	CALL POLY_COE(K1,K2,X1,Y1,KX,KY,TM,LOW_LINE)
 	TM = Y2-Y1
 	CALL POLY_COE(K1,K2,X1,Y1,KX,KY,TM,UP_LINE)
 	LLX = (UP_LINE-LOW_LINE)*SQRT(NXY*NXY+1.0)
 END IF

END SUBROUTINE

SUBROUTINE POLY_COE(ORD1,ORD2,XF,YF,KX,KY,TM,R_INT)
 IMPLICIT NONE 
 INTEGER :: ORD1,ORD2
 INTEGER :: IK,JK,KK,N,I,J,K
 INTEGER :: K1,K2,K3,N1,N2,N3,NN,IK1,IK2,JK1,JK2,KK1,KK2
 REAL (KIND = 8) :: XF,YF,KX,KY,R_INT,TM
 REAL (KIND = 8) :: POLY_X(0:ORD1),POLY_Y(0:ORD2)
 REAL (KIND = 8) :: POLY_XY(0:ORD1+ORD2)
 
 POLY_X = 0.0; POLY_Y = 0.0
 POLY_XY = 0.0
 
 DO IK = 0,ORD1
 	JK = ORD1-IK
 	N1 = 1; N2 = 1; NN = 1
 	DO I = 1,ORD1
 		NN = NN*I
 	END DO
 	DO I = 1,IK
 		N1 = N1*I
 	END DO
 	DO I = 1,JK
 		N2 = N2*I
 	END DO
 	POLY_X(IK) = POLY_X(IK)+NN/N1/N2*1.0*(XF**JK)*(KX**IK)
 END DO
 DO IK = 0,ORD2
 	JK = ORD2-IK
 	N1 = 1; N2 = 1; NN = 1
 	DO I = 1,ORD2
 		NN = NN*I
 	END DO
 	DO I = 1,IK
 		N1 = N1*I
 	END DO
 	DO I = 1,JK
 		N2 = N2*I
 	END DO
 	POLY_Y(IK) = POLY_Y(IK)+NN/N1/N2*1.0*(YF**JK)*(KY**IK)
 END DO
 DO IK = 0,ORD1
 	DO JK = 0,ORD2
 		POLY_XY(IK+JK) = POLY_XY(IK+JK)+POLY_X(IK)*POLY_Y(JK)
 	END DO
 END DO
 R_INT = 0.0
 DO IK = 0,ORD1+ORD2
 	R_INT = R_INT+POLY_XY(IK)*(TM**(IK+1))/(IK+1.0)
 END DO
 
END SUBROUTINE POLY_COE

SUBROUTINE MFD_SOLVER_NN(FACE_NUM,NC,RC,RNC,ORD_NUM,MCF,PC)
 IMPLICIT NONE 
 INTEGER :: FACE_NUM,ORD_NUM
 INTEGER :: IK,JK,KK
 REAL (KIND = 8) :: NC(FACE_NUM,ORD_NUM),RC(FACE_NUM,ORD_NUM)
 REAL (KIND = 8) :: RNC(ORD_NUM,ORD_NUM),RRNC(FACE_NUM,ORD_NUM),MCF(FACE_NUM,FACE_NUM)
 REAL (KIND = 8) :: IRNC(ORD_NUM,ORD_NUM),INNC(ORD_NUM,ORD_NUM),PC(FACE_NUM,FACE_NUM)
 REAL (KIND = 8) :: LAMAC,NNC(ORD_NUM,ORD_NUM),NNNC(FACE_NUM,ORD_NUM),MCFP(FACE_NUM,FACE_NUM)
 REAL (KIND = 8) :: NC_T(FACE_NUM,ORD_NUM),NC_B(FACE_NUM,ORD_NUM)

 ! Inverse of RNC
 CALL LU_INVERSE(ORD_NUM,RNC,IRNC)
 
 ! Compute DG^(-1)
 RRNC = 0.0
 DO IK = 1,FACE_NUM
 	DO JK = 1,ORD_NUM
 		DO KK = 1,ORD_NUM
 			RRNC(IK,JK) = RRNC(IK,JK)+RC(IK,KK)*IRNC(KK,JK)
 		END DO
 	END DO 
 END DO
 ! Compute MCF
 MCF = 0.0
 DO IK = 1,FACE_NUM
 	DO JK = 1,FACE_NUM
 		DO KK = 1,ORD_NUM
 			MCF(IK,JK) = MCF(IK,JK)+RRNC(IK,KK)*RC(JK,KK)
 		END DO
 	END DO
 END DO 

 NNC = 0.0
 DO IK = 1,ORD_NUM
 	DO KK = 1,ORD_NUM
 		DO JK = 1,FACE_NUM	
 			NNC(IK,KK) = NNC(IK,KK)+NC(JK,IK)*NC(JK,KK)
 		END DO
 	END DO 
 END DO
 
 ! Inverse of NNC
 CALL LU_INVERSE(ORD_NUM,NNC,INNC)
 ! Compute NNNC
 NNNC = 0.0
 DO IK = 1,FACE_NUM
 	DO JK = 1,ORD_NUM
 		DO KK = 1,ORD_NUM
 			NNNC(IK,JK) = NNNC(IK,JK)+NC(IK,KK)*INNC(KK,JK)
 		END DO
 	END DO
 END DO
 ! Compute MCFP
 MCFP = 0.0
 DO IK = 1,FACE_NUM
 	DO JK = 1,FACE_NUM
 		DO KK = 1,ORD_NUM
 			MCFP(IK,JK) = MCFP(IK,JK)+NNNC(IK,KK)*NC(JK,KK)  
 		END DO
 	END DO
 END DO
 
 PC = -MCFP
 DO IK = 1,FACE_NUM
 	PC(IK,IK) = PC(IK,IK)+1.0
 END DO
 
END SUBROUTINE 

SUBROUTINE LU_INVERSE(RF_NUM,A,A_INV)
 IMPLICIT NONE 
 INTEGER :: RF_NUM
 REAL (KIND = 8) :: A(RF_NUM,RF_NUM),A_INV(RF_NUM,RF_NUM),A_TEM(RF_NUM)
 REAL (KIND = 8) :: L(RF_NUM,RF_NUM),U(RF_NUM,RF_NUM),LI(RF_NUM,RF_NUM),UI(RF_NUM,RF_NUM)
 REAL (KIND = 8) :: XK
 INTEGER :: IK,JK,KK,NK_B
 INTEGER :: IND_B(RF_NUM,2)
 
 NK_B = 0; IND_B = 0
 DO IK = 1,RF_NUM
 	IF (ABS(A(IK,IK)).LT.1.0E-15) THEN 
 		JK = IK+1
 		DO WHILE (ABS(A(JK,IK)).LT.1.0E-15.AND.JK.LT.RF_NUM)
 			JK = JK+1
 		END DO			
 		DO KK = 1,RF_NUM
 			A_TEM(KK) = A(JK,KK)
 		END DO
 		DO KK = 1,RF_NUM
 			A(JK,KK) = A(IK,KK)
 		END DO
 		DO KK = 1,RF_NUM
 			A(IK,KK) = A_TEM(KK)
 		END DO
 		NK_B = NK_B+1
 		IND_B(NK_B,1) = JK; IND_B(NK_B,2) = IK
 	END IF
 END DO
 
 
 L = 0.0; U = 0.0
 DO IK = 1,RF_NUM
 	JK = IK
 	L(IK,JK) = 1.0
 END DO
 
! LU Decomposition
 DO JK = 1,RF_NUM
 	U(1,JK) = A(1,JK)
 END DO
 DO IK = 2,RF_NUM
 	L(IK,1) = A(IK,1)/U(1,1)
 	DO JK = 2,IK-1
 		XK = A(IK,JK)
 		DO KK = 1,JK-1
 			XK = XK-L(IK,KK)*U(KK,JK)
 		END DO
 		IF (ABS(U(JK,JK)).LT.1.0E-18) THEN 
 			WRITE (*,*) 'WARNING'
 			L(IK,JK) = 0.0
 		ELSE 
 			L(IK,JK) = XK/U(JK,JK)
 		END IF
 	END DO
 	DO JK = IK,RF_NUM
 		XK = A(IK,JK)
 		DO KK = 1,JK-1
 			XK = XK-L(IK,KK)*U(KK,JK)
 		END DO
 		U(IK,JK) = XK/1.0
 	END DO
 END DO
 
! Computing the inverse of L AND U MATRIX
! For U
 LI = 0.0; UI = 0.0
 DO IK = 1,RF_NUM
 	DO JK = 1,RF_NUM
 		IF (IK.EQ.JK) THEN 
 			XK = 1.0
 		ELSE 
 			XK = 0.0
 		END IF
 		DO KK = 1,JK-1
 			XK = XK-UI(IK,KK)*U(KK,JK)
 		END DO
 		IF (ABS(U(JK,JK)).LT.1.0E-18) THEN 
 			UI(IK,JK) = 0.0
 		ELSE  
 			UI(IK,JK) = XK/U(JK,JK)
 		END IF
 	END DO
 END DO

! For L
 DO IK = 1,RF_NUM
 	DO JK = RF_NUM,1,-1
 		IF (IK.EQ.JK) THEN 
 			XK = 1.0
 		ELSE 
 			XK = 0.0
 		END IF
 		DO KK = RF_NUM,JK+1,-1
 			XK = XK-LI(IK,KK)*L(KK,JK)
 		END DO
 		LI(IK,JK) = XK
 	END DO
 END DO

! For the final inverse of A
 A_INV = 0.0
 DO IK = 1,RF_NUM
 	DO JK = 1,RF_NUM
 		DO KK = 1,RF_NUM
 			A_INV(IK,JK) = A_INV(IK,JK)+UI(IK,KK)*LI(KK,JK)
 		END DO
 	END DO
 END DO

 DO IK = RF_NUM,1,-1
 	IF (IND_B(IK,1).NE.0) THEN 
 		DO KK = 1,RF_NUM
 			A_TEM(KK) = A_INV(KK,IND_B(IK,1))
 		END DO
 		DO KK = 1,RF_NUM
 			A_INV(KK,IND_B(IK,1)) = A_INV(KK,IND_B(IK,2)) 
 		END DO
 		DO KK = 1,RF_NUM
 			A_INV(KK,IND_B(IK,2)) = A_TEM(KK)
 		END DO
 	END IF
 END DO
 
 DO IK = RF_NUM,1,-1
 	IF (IND_B(IK,1).NE.0) THEN 
 		DO KK = 1,RF_NUM
 			A_TEM(KK) = A(KK,IND_B(IK,1))
 		END DO
 		DO KK = 1,RF_NUM
 			A(KK,IND_B(IK,1)) = A(KK,IND_B(IK,2)) 
 		END DO
 		DO KK = 1,RF_NUM
 			A(KK,IND_B(IK,2)) = A_TEM(KK)
 		END DO
 	END IF
 END DO
 
END SUBROUTINE 
